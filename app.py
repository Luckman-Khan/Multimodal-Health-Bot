import os
import requests
import google.generativeai as genai
from flask import Flask, request
from flask_sqlalchemy import SQLAlchemy
from twilio.twiml.messaging_response import MessagingResponse
from dotenv import load_dotenv
import logging

# --- 1. Configuration & Setup ---
load_dotenv()
app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

# Database Config (Works on Render automatically, or local SQLite)
# On Render, add a PostgreSQL database and it sets DATABASE_URL automatically
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///users.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# API Keys
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
genai.configure(api_key=GEMINI_API_KEY)

# --- 2. Database Model (User Profiles) ---
class User(db.Model):
    phone = db.Column(db.String(20), primary_key=True)
    # We store the medical profile as a single text block for the AI to read
    # e.g., "Age: 30, Gender: Female, Diabetic, Allergic to Penicillin"
    medical_profile = db.Column(db.Text, default="No specific medical history provided.")

# Create DB tables if they don't exist
with app.app_context():
    db.create_all()

# --- 3. The Brain (System Instructions) ---
def get_system_prompt(user_profile):
    return f"""
    You are an advanced AI Medical Assistant.
    
    CONTEXT ABOUT USER:
    The user's medical profile is: "{user_profile}".
    Use this profile to personalize your advice (e.g., if diabetic, warn about sugar).

    YOUR TASKS:
    1. **Language Detection**: Automatically detect the language of the user's message/image caption.
    2. **Respond in the SAME Language**: If they ask in Hindi, answer in Hindi.
    3. **Profile Extraction**: If the user provides new medical info (e.g., "I have high BP", "I am 25"), 
       add a specific tag at the end of your response like this: [[UPDATE_PROFILE: <summary of new info>]].
    4. **Structure**: format your medical advice strictly as follows:
       - ü©∫ **Analysis**: What do you think is happening?
       - üíä **Remedy/Advice**: Immediate steps or home remedies.
       - ‚ö†Ô∏è **Precaution**: Specific warnings (check for interactions if they mentioned medicines).
       - üè• **When to see a Doctor**: Red flag symptoms.
    
    SAFETY PROTOCOL:
    - If the user implies suicide, chest pain, or unconsciousness, start with "üö® EMERGENCY" and tell them to call a hospital.
    - Always end with: "Disclaimer: I am an AI. Consult a doctor for medical decisions."
    """

def get_gemini_response(text_input, image_data, mime_type, current_profile):
    try:
        model = genai.GenerativeModel(
            model_name='gemini-1.5-flash',
            system_instruction=get_system_prompt(current_profile)
        )
        
        content = []
        if text_input:
            content.append(text_input)
        if image_data:
            content.append({"mime_type": mime_type, "data": image_data})

        response = model.generate_content(content)
        return response.text
    except Exception as e:
        logging.error(f"Gemini API Error: {e}")
        return "‚ö†Ô∏è Service unavailable temporarily. Please try again."

# --- 4. The Route ---
@app.route("/whatsapp", methods=['POST'])
def whatsapp_reply():
    incoming_msg = request.values.get('Body', '').strip()
    media_url = request.values.get('MediaUrl0')
    sender_phone = request.values.get('From')

    resp = MessagingResponse()
    msg = resp.message()

    try:
        # A. Fetch or Create User
        user = User.query.get(sender_phone)
        if not user:
            user = User(phone=sender_phone)
            db.session.add(user)
            db.session.commit()
            # First time greeting (optional logic could go here)

        # B. Handle Image Download
        image_data = None
        mime_type = None
        if media_url:
            # Twilio requires auth to download media
            media_req = requests.get(media_url, auth=(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN))
            if media_req.status_code == 200:
                mime_type = media_req.headers.get('Content-Type')
                image_data = media_req.content
                if not incoming_msg:
                    incoming_msg = "Please analyze this medical image."
            else:
                msg.body("‚ùå Failed to download image.")
                return str(resp)

        # C. Get AI Response
        ai_reply = get_gemini_response(incoming_msg, image_data, mime_type, user.medical_profile)

        # D. Check for Profile Updates (Smart Memory)
        # We look for the tag [[UPDATE_PROFILE: ...]] generated by the AI
        if "[[UPDATE_PROFILE:" in ai_reply:
            try:
                # Extract the new info
                start = ai_reply.find("[[UPDATE_PROFILE:") + 17
                end = ai_reply.find("]]", start)
                new_info = ai_reply[start:end].strip()
                
                # Update DB
                current_info = user.medical_profile
                if "No specific" in current_info:
                    user.medical_profile = new_info
                else:
                    user.medical_profile = f"{current_info}, {new_info}"
                
                db.session.commit()
                
                # Remove the tag from the message sent to user
                ai_reply = ai_reply.replace(f"[[UPDATE_PROFILE: {new_info}]]", "")
                ai_reply = ai_reply.replace("[[UPDATE_PROFILE:", "") # Cleanup remnants
            except Exception as e:
                logging.error(f"Profile update failed: {e}")

        msg.body(ai_reply)

    except Exception as e:
        logging.error(f"Critical Error: {e}")
        msg.body("Sorry, I'm having trouble connecting right now.")

    return str(resp)

if __name__ == "__main__":
    # In production/render, this runs via Gunicorn
    app.run(port=5000, debug=True)